@Tutorial(time: 10) {
    @Intro(title: "Adding ParseObjects") {
        Learn how to create and configure ParseObject models for your ParseServerSwift application.
        
        ParseObject models in your server should mirror the same models in your client applications. This ensures consistency and allows you to share code between client and server.
        
        For more information on creating ParseObjects, see the [Parse Swift API documentation](https://swiftpackageindex.com/netreconlab/Parse-Swift/documentation/parseswift/parseobject) and [Parse Swift tutorials](https://netreconlab.github.io/Parse-Swift/release/tutorials/parseswift/).
		
		@Image(source: chapter-getting-started.png, alt: "Foundation building blocks representing ParseObjects as the foundation of data storage")
    }
    
    @Section(title: "Understanding ParseObjects") {
        @ContentAndMedia {
            ParseObjects are Swift structs that conform to the ParseObject protocol. They represent data stored in your Parse Server database.
        }
        
        @Steps {
            @Step {
                Every ParseObject must have these required properties:
                - `objectId`: Unique identifier
                - `createdAt`: Creation timestamp
                - `updatedAt`: Last update timestamp
                - `ACL`: Access Control List
                - `originalData`: Raw data from server
            }
            
            @Step {
                It's recommended to add all of your `ParseObject` models to the `Models` directory:
                
                ```
                Sources/
                  ParseServerSwift/
                    Models/
                      User.swift
                      GameScore.swift
                      Post.swift
                      Comment.swift
                ```
            }
        }
    }
    
    @Section(title: "Creating a Basic ParseObject") {
        @ContentAndMedia {
            Let's create a GameScore model to track player scores in a game.
        }
        
        @Steps {
            @Step {
                Create a new Swift file `GameScore.swift` in the Models directory. This struct conforms to `ParseObject` protocol and includes all required properties.
                
                @Code(name: "GameScore.swift", file: GameScore.swift)
            }
            
            @Step {
                Add the `merge` method to handle updates correctly:
                
                ```swift
                struct GameScore: ParseObject {
                    // ... required properties
                    var points: Int?
                
                    // Implement merge for proper updates
                    func merge(with object: Self) throws -> Self {
                        var updated = try mergeParse(with: object)
                        if updated.shouldRestoreKey(\.points,
                                                     original: object) {
                            updated.points = object.points
                        }
                        return updated
                    }
                }
                ```
                
                The `merge` method ensures your custom properties are properly handled during updates.
            }
            
            @Step {
                You can add as many custom properties as you need:
                
                ```swift
                struct GameScore: ParseObject {
                    // Required properties...
                    
                    // Custom properties
                    var points: Int?
                    var playerName: String?
                    var cheatMode: Bool?
                    var level: Int?
                    
                    // Merge implementation
                    func merge(with object: Self) throws -> Self {
                        var updated = try mergeParse(with: object)
                        if updated.shouldRestoreKey(\.points, original: object) {
                            updated.points = object.points
                        }
                        if updated.shouldRestoreKey(\.playerName, original: object) {
                            updated.playerName = object.playerName
                        }
                        if updated.shouldRestoreKey(\.cheatMode, original: object) {
                            updated.cheatMode = object.cheatMode
                        }
                        if updated.shouldRestoreKey(\.level, original: object) {
                            updated.level = object.level
                        }
                        return updated
                    }
                }
                ```
            }
        }
    }
    
    @Section(title: "Creating the User Model") {
        @ContentAndMedia {
            The User model is special because it represents authenticated users and must conform to ParseCloudUser on the server.
        }
        
        @Steps {
            @Step {
                The `ParseUser` in `ParseServerSwift` should conform to `ParseCloudUser` instead of `ParseUser`. This is because `ParseCloudUser` contains additional server-side properties.
                
                **Important**: On client apps, always use `ParseUser`, not `ParseCloudUser`.
                
                @Code(name: "User.swift", file: User.swift)
            }
            
            @Step {
                Add any custom properties your application needs:
                
                ```swift
                struct User: ParseCloudUser {
                    // Required properties...
                    
                    // Custom properties
                    var displayName: String?
                    var profilePicture: ParseFile?
                    var level: Int?
                    var lastLogin: Date?
                }
                ```
            }
            
            @Step {
                Be sure to add all additional properties you have in your `_User` class on Parse Server. The server-side model should match your database schema exactly.
            }
        }
    }
    
    @Section(title: "Working with Relationships") {
        @ContentAndMedia {
            ParseObjects can have relationships with other ParseObjects using pointers and relations.
        }
        
        @Steps {
            @Step {
                **Pointer**: A one-to-one relationship. Add a property of another ParseObject type:
                
                ```swift
                struct Post: ParseObject {
                    var objectId: String?
                    var createdAt: Date?
                    var updatedAt: Date?
                    var ACL: ParseACL?
                    var originalData: Data?
                    
                    var title: String?
                    var content: String?
                    var author: User?  // Pointer to User
                    
                    func merge(with object: Self) throws -> Self {
                        var updated = try mergeParse(with: object)
                        if updated.shouldRestoreKey(\.title, original: object) {
                            updated.title = object.title
                        }
                        if updated.shouldRestoreKey(\.content, original: object) {
                            updated.content = object.content
                        }
                        if updated.shouldRestoreKey(\.author, original: object) {
                            updated.author = object.author
                        }
                        return updated
                    }
                }
                ```
            }
            
            @Step {
                **Array**: A one-to-many relationship using an array of ParseObjects:
                
                ```swift
                struct Post: ParseObject {
                    // ... other properties
                    
                    var tags: [Tag]?  // Array of Tag objects
                    var relatedPosts: [Post]?  // Array of other Posts
                }
                ```
            }
            
            @Step {
                **Relation**: Use ParseRelation for large collections:
                
                ```swift
                import ParseSwift
                
                struct User: ParseCloudUser {
                    // ... required properties
                    
                    var friends: ParseRelation<User>?  // Many-to-many
                    var followers: ParseRelation<User>?
                }
                ```
                
                Relations are more efficient for large collections compared to arrays.
            }
        }
    }
    
    @Section(title: "Using ParseFile") {
        @ContentAndMedia {
            ParseFile allows you to store files associated with your ParseObjects.
        }
        
        @Steps {
            @Step {
                Add ParseFile properties to store files:
                
                ```swift
                struct Profile: ParseObject {
                    var objectId: String?
                    var createdAt: Date?
                    var updatedAt: Date?
                    var ACL: ParseACL?
                    var originalData: Data?
                    
                    var user: User?
                    var profilePicture: ParseFile?
                    var coverPhoto: ParseFile?
                    var documents: [ParseFile]?
                    
                    func merge(with object: Self) throws -> Self {
                        var updated = try mergeParse(with: object)
                        if updated.shouldRestoreKey(\.user, original: object) {
                            updated.user = object.user
                        }
                        if updated.shouldRestoreKey(\.profilePicture, original: object) {
                            updated.profilePicture = object.profilePicture
                        }
                        if updated.shouldRestoreKey(\.coverPhoto, original: object) {
                            updated.coverPhoto = object.coverPhoto
                        }
                        if updated.shouldRestoreKey(\.documents, original: object) {
                            updated.documents = object.documents
                        }
                        return updated
                    }
                }
                ```
            }
        }
    }
    
    @Section(title: "Advanced: Custom Codable Keys") {
        @ContentAndMedia {
            If your database uses different naming conventions, you can map Swift property names to database column names.
        }
        
        @Steps {
            @Step {
                Use CodingKeys to map property names:
                
                ```swift
                struct GameScore: ParseObject {
                    var objectId: String?
                    var createdAt: Date?
                    var updatedAt: Date?
                    var ACL: ParseACL?
                    var originalData: Data?
                    
                    var points: Int?
                    var playerName: String?
                    
                    // Map Swift names to database names
                    enum CodingKeys: String, CodingKey {
                        case objectId
                        case createdAt
                        case updatedAt
                        case ACL
                        case originalData
                        case points
                        case playerName = "player_name"  // Database uses snake_case
                    }
                    
                    func merge(with object: Self) throws -> Self {
                        var updated = try mergeParse(with: object)
                        if updated.shouldRestoreKey(\.points, original: object) {
                            updated.points = object.points
                        }
                        if updated.shouldRestoreKey(\.playerName, original: object) {
                            updated.playerName = object.playerName
                        }
                        return updated
                    }
                }
                ```
            }
        }
    }
    
    @Section(title: "Sharing Models Between Client and Server") {
        @ContentAndMedia {
            To reduce code duplication, share ParseObject models between your client apps and ParseServerSwift.
        }
        
        @Steps {
            @Step {
                Create a Swift Package with your shared models:
                
                ```
                MySharedModels/
                  Package.swift
                  Sources/
                    MySharedModels/
                      GameScore.swift
                      Post.swift
                      Comment.swift
                ```
                
                Learn more in [Apple's WWDC session on server-side Swift](https://developer.apple.com/videos/play/wwdc2022/110360/).
            }
            
            @Step {
                **Important**: The User model is different:
                - Server uses `ParseCloudUser` (in ParseServerSwift)
                - Client uses `ParseUser` (in iOS/macOS apps)
                
                Keep separate User models or use conditional compilation:
                
                ```swift
                #if canImport(Vapor)
                import Vapor
                typealias UserBase = ParseCloudUser
                #else
                typealias UserBase = ParseUser
                #endif
                
                struct User: UserBase {
                    // ... properties
                }
                ```
            }
        }
    }
}

